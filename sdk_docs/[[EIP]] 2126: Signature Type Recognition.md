- By [[Pedro Gomes]]
- [Discussion on Ethereum Magicians](https://ethereum-magicians.org/t/erc-2126-signature-type-recognition/3392)
- [Full text](https://github.com/pedrouid/EIPs/blob/202d578acb76bb4b8d0f46630eff4965ca61c092/EIPS/eip-2126.md)
    - ---
eip: 2126
title: Signature Type Recognition
author: Pedro Gomes (@pedrouid), Ramesh Nair (@hiddentao)
discussions-to: https://ethereum-magicians.org/t/erc-2126-signature-type-recognition/3392
status: Draft
type: Standards Track
category: ERC
created: 2019-06-19
requires: 712, 1271
---

## Abstract

Enable Dapps to be able to recognize how a given signature was signed (e.g. by owner of a smart contract, EOA, etc) so that they can use the correct mechanism to verify the signature.

## Motivation

Currently Dapp developers are unable to identify the _type_ of a signature. By _type_ we are referring to how the signature was generated.

If the Dapp sees the user's EOA (externally-owned address) as their account, then any signature will have been generated by the private key of that address, and the Dapp would easily be able to validate the signer of this signature as being the same account. On the other hand, if what a Dapp sees is a user's smart contract address (which is indirectly owned by the user's EOA) then obviously the Dapp would find a mismatch between signer address and account address.

A real-world example would be using Metamask or [WalletConnect](https://walletconnect.org), where you could expose accounts which are either EOA accounts or smart contract accounts, which in turn would provide similar signatures but require different validation processes.

The solution to this issue is to append a byte to the end of the signature which will correspond to one of the given signature types listed below. Dapps can then query this byte to know how to validate the given signature.

## Specification

### Formatting Signatures

Example for [EIP-712](#EIP712) compliant signatures:

```javascript
const signatureBuffer = Buffer.concat([
  ethUtil.toBuffer(ecSignatureRSV.v),
  ethUtil.toBuffer(ecSignatureRSV.r),
  ethUtil.toBuffer(ecSignatureRSV.s),
  ethUtil.toBuffer(SignatureType.EIP712)
]);
```

### Signature Types

All signatures are represented as a byte array of arbitrary length, where the last byte (the "signature byte") specifies the signature type. The signature type is popped from the signature byte array before validation. The following signature types are supported within the protocol:

| Signature byte | Signature type      |
| -------------- | ------------------- |
| 0x00           | [Illegal](#illegal) |
| 0x01           | [Invalid](#invalid) |
| 0x02           | [EIP712](#eip712)   |
| 0x03           | [EthSign](#ethsign) |
| 0x04           | [Wallet](#wallet)   |

**Illegal**

The is the default value of the signature byte. A transaction that includes an Illegal signature will be reverted. Therefore, users must explicitly specify a valid signature type.

**Invalid**

An `Invalid` signature always returns false. An invalid signature can always be recreated and is therefore offered explicitly. This signature type is largely used for testing purposes.

**EIP712**

An [`EIP712`](https://eips.ethereum.org/EIPS/eip-712) signature is considered valid if the address recovered from calling ecrecover with the given hash and decoded `v`, `r`, `s` values is the same as the specified signer. In this case, the signature is encoded in the following way:

| Offset | Length | Contents            |
| ------ | ------ | ------------------- |
| 0x00   | 1      | v (always 27 or 28) |
| 0x01   | 32     | r                   |
| 0x21   | 32     | s                   |

**EthSign**

An `EthSign` signature is considered valid if the address recovered from calling ecrecover with the an EthSign-prefixed hash and decoded `v`, `r`, `s` values is the same as the specified signer.

The prefixed `msgHash` is calculated with:

```
string constant ETH_PERSONAL_MESSAGE = "\x19Ethereum Signed Message:\n32";
bytes32 msgHash = keccak256(abi.encodePacked(ETH_PERSONAL_MESSAGE, hash));
```

`v`, `r`, and `s` are encoded in the signature byte array using the same scheme as [EIP712 signatures](#EIP712).

**Wallet**

The `Wallet` signature type allows an EOA account to sign messages on behalf of a smart contract account.

As per [EIP-1271](https://eips.ethereum.org/EIPS/eip-1271), smart contract accounts can validate signatures using the public method `isValidSignature`. This method has the following interface:

```typescript=
// @dev Verifies that a signature is valid.
// @param hash Message hash that is signed.
// @param signerAddress Address of signer.
// @param signature Proof of signing.
// @return Validity of order signature.
function isValidSignature(
    bytes32 hash,
    address signerAddress,
    bytes memory signature
)
    public
    view
    returns (bool isValid);
```

### Web3 JSON API support

We suggest appending an _optional_ parameter to existing Web3 signature functions. This parameter would contain key-value pairs. This is so that:

- Web3 clients can choose when and where to include a signature type byte.
- Existing code using these methods doesn't need to change.
- Additional options can easily be added in future.

Example using `web3.js`:

```js
web3.eth.personal.sign(
    "...data...",
    "0x...",
    "password",
    null, // callback
    {
        includeType: true, // informs signer to include signature type
    }
})
```

## Rationale

Going forward, ever more Ethereum account holders will be using "proxy" wallets (e.g. [Gnosis Safe](https://safe.gnosis.io/)) combined with tools such as [Wallet Connect](https://walletconnect.org/) to interact with desktop Dapps.

Since only an externally-owned address (and not a smart contract) can generate a signature, it becomes essential for code which verifies the signer of a signature to know when a given signature was generated on behalf of a smart contract by an externally-owned address.

This EIP essentially advocates for adding metadata to an Ethereum signature in order to facilitate this. It complements existing EIPs (712, 1271) and the specification above is [already actively in production use by the 0x project](https://github.com/0xProject/0x-protocol-specification/blob/master/v2/v2-specification.md#signature-types) - indeed, the specification is based largely on their work. 

The specification above takes into account all the different ways in which signatures may be generated today, whilst also being future-proof. 

Since the change could break signature parsing (by adding the extra byte) it requires an explicit opt-in by providing an additional parameter to the web3 signing methods. 

## Copyright

Copyright and related rights waived via [CC0](https://creativecommons.org/publicdomain/zero/1.0/).
