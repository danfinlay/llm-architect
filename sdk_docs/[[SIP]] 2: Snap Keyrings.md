- https://github.com/MetaMask/SIPs/blob/main/SIPS/sip-2.md
- [Discussion issue on GitHub](https://github.com/MetaMask/SIPs/discussions/10)
- My summary
    - Provides a method for a [[wallet]] like [[MetaMask]] to allow a [[dapp]] to propose additional account managers, either different ways of managing [[externally owned account (EOA)]]s or [[contract account]]s.
    - Can provide a way for wallets like MetaMask to experiment with new account types
        - New [[hardware wallet]] integrations
            - New cheap, open source hardware wallets like [[firefly ([[hardware wallet]])]]
            - Newer/smaller hardware wallet companies like [[CoolWallet]]
        - Other contract-level [[account abstraction (AA)]]
            - [[[[Gnosis]] SAFE]]
            - [[[[EIP]] 4337: [[account abstraction (AA)]] via Entry Point Contract]]
            - [[Delegatable Eth]]
                - as a module to another contract account
                - as a way of representing [[delegation]]s that allow some limited usage of the represented account.
        - Connecting to [[dapp]]s on behalf of multi-party accounts like [[DAO]]s.
            - By loading a [[DAO]] into [[[[MetaMask]] Snaps]], we could streamline the process of proposing complicated transactions to a DAO, as well as the process of being notified of such proposals and approving them.
- Notes
    - During initial connection of the DApp to the Wallet using provider.connect() call, the wallet finds snaps that can support requested functionality using below algorithm.
        - Wallet splits connection arguments into namespaces.
        - For each namespace, the wallet finds an installed snap that supports all requested chains, methods and events.
            - If there are multiple such snaps, the choice, which one of those to use, is undefined and implementation dependent.
            - Support for a namespace MUST NOT be split between multiple snaps. 
For example, one snap can't support one chain while other snap supports 
second chain.
        - The wallet returns information of supported namespaces back to the DApp inside a Session object. The amount of supported namespaces MAY be smaller than the amount of requested namespaces.
- Feedback
    - I might add a bit from [my above section](((uQTU735i8))) talking about examples of new account types that are made possible by the proposal. Just because I like a motivation section that helps ignite the imagination.
    - > The wallet implementation SHOULD support [WalletConnect v2.0](https://docs.walletconnect.com/2.0/) protocol.
        - Maybe this could be [[[[EIP]] 1193: Ethereum Provider JavaScript API]]? WC is more opinionated about transport, so I think it would be best if we described the provided interface in the most transport-agnostic terms.
    - is the `chainId` variable able to go high enough for "permissionless extensibility"? I'd like any trivial object, like a lightbulb, to be able to have a unique chain. (Maybe that's just not for evm chains?)
    - > If there are multiple such snaps, the choice, which one of those to use, is undefined and implementation dependent.
        - I appreciate this being undefined for now. For short term I would recommend not attempting deduplication, since there are various pitfalls to that implementation. A simple shortstop would be that during the account selection step of dapp connection, allow the user to select from a list of accounts where each one is labeled by its key provider.
            - Being explicit about which account provider can help a user "keep the books separate" between key managers that might be intended for different uses: One hardware wallet for business, one for pleasure.
            - This becomes significantly more important in an environment like [[Delegatable Eth]], where a user might have multiple delegations that allow them to take actions "on behalf of" one central account, but each of those delegation paths could represent a different reason/organization to have that privilege.
        - Another approach is to just allow the user to select an account, and at signature time let them select the account provider
            - could allow nice experiences like letting a user decide which hardware wallet is most accessible to them at that time.
    - This SIP gets into talking about critical uses of a `namespace` before defining a namespace. I might recommend defining namespace earlier.
        - Some passages that are hard to read without reading ahead and then hopping back
            - > Wallet splits connection arguments into namespaces.
            - > Support for a namespace MUST NOT be split between multiple snaps. For 
example, one snap can't support one chain while other snap supports 
second chain.
    - > Support for a namespace MUST NOT be split between multiple snaps. For example, one snap can't support one chain while other snap supports  second chain.
        - I'm unclear what this means.
            - We definitely do want to be able to have snaps that handle different namespaces, which I'm pretty sure we agree with, but seems to contradict this.
            - We also want multiple snaps to be able to provide accounts for the same protocol (we might have several eth account snaps, for example, to represent hardware wallets, contract accounts, and DAO memberships)
        - Revisiting after reading the permissions, I think I have an interpretation.
            - Once a snap-provided account is selected by a user to be exposed to a dapp, that dapp's requests for that account will all be passed through to that one snap.
                - Some reasons I think this might be unnecessary to state
                    - Some account managers are not able to expose all methods (contract accounts can't perform signatures, and some hardware wallets don't support some signature methods).
                    - A snap could claim it supports many methods, but actually forward some of them to another snap, and that's not really any of our business.
    - I see that snap permissions are specified in the manifest. I'm pretty sure this means you can also do `wallet_requestPermissions`. I might suggest either:
        - Just show the permission request object, and link out to a guide that covers the two methods.
        - Show both methods to request the permissions.
    - I'm ecstatic that event handlers are part of this specification.
        - I'd also be excited for snaps to have a general ability to register `on` and `off` methods, despite not exposing other account management methods.
    - It's great that we have these keyrings declaring what methods they support. It would also be great if we could expose this to sites in some form. I had mentioned this in [[[[EIP]] 2255: Wallet Permissions System]], and doesn't need to be part of this proposal, but the possible value of dapp-side [[feature detection]] is even stronger with this proposal.
    - Recommendations for safety
        - Since we are using a [[JSON-RPC API]] to expose these sensitive methods, there is risk of account snap developers writing a [[confused deputy]] vulnerability.
            - These issues occur when there are >2 parties coordinating privileges.
            - Example
                - `Snap Alice` might have permission to interact with several of a user's other accounts. For example, so that a contract account snap can trigger transactions from key managers.
                - A user might only want to grant `Dapp Bob` with access to `Account Carol`.
                - `Snap Alice` is now responsible for ensuring that any of its methods provided to `Dapp Bob` are restricted to interactions with `Account Carol`.
                - If `Snap Alice` exposes any methods with an `accountId` parameter, this offers `Dapp Bob` an opportunity to provide a chosen string for an account that it has not been permitted access to.
                - This means that a Snap account that enlists many other accounts to imbue it with its total authority must implement its own internal permissions scheme to ensure that it never grants unintended access to some of its capabilities.
                - Long term, alternatives to [[JSON-RPC API]] such as [[CapTP]] can allow snaps much more specific "object passing" type delegation that makes these types of vulnerabilities trivially impossible.
    - Might as well include a link to the keyring protocol when mentioning it.
