- A document for exploring the ways that programming for ocaps lends itself to different styles of composition and architecture.
- Projects where you can see this in action
    - [[Spritely]]
    - My latest experiment to this end: [[Caputi]]
        - Some interesting relationship to [[propagator]]
- It's different from normal programming!
    - Global variables are disallowed __for good reason__, and so any required resources must be passed in from the root of the program, or acquired from a communication channel that is passed in.
        - The program should run with permissions endowed by the user.
        - The program's components should run with permissions endowed by the program's root.
        - The components themselves must be deliberate & explicit about what is shared between each other and when.
    - The code organization fundamentally represents units that may be shared
        - One of the virtues of [[object capability (ocap)]] programming is the opportunity to do-away with writing API servers & clients, and instead "pass references" over object/process/network/social boundaries.
        - In order to benefit from the convenient security model of "passing references", the object model must be designed in a way that emphasizes a sensible sharing policy.
        - A sensible sharing policy must be
            - Granular enough to allow for respecting the [[principle of least authority (POLA)]].
            - Coherent enough that a person considering passing an object at a glance intuitively understands the authority that is contained therein. [[principle of appropriate boundaries]]
        - Objects should be divided not only into "logical segments", but into segments of logical ownership, in the sense of what one agent might choose to trust another agent with.
        - This principle is recursive: An object's own responsibilities should also be subdivided into "capabilities" (functions and objects) to facilitate the easiest subdivision of responsibilities for sharing & collaboration.
        - Examples
            - In a game, the Player objects should be safe to pass to other players.
                - Challenge: There is a difference between the Player object that a player gets to represent themselves, and the view/reference the player that their opponents get.
                    - This can be solved with a [[attenuation]], and so as long as players only get disrupted references to each other (read only, for example), then this can work safely.
            - In a game, a player's Units should also be safe to share with teammates.
    - If you assume a program that may be scaled across machines and processes, then interactions between objects must be async first ([[The Actor Model]])
        - Any interactions that require synchronized orchestration between multiple actors must therefore employ locks or semaphores.
            - To avoid [[deadlocks]], these locks must not be permanent, but may be time limited options on atomicity. Maybe a gas system like [[Ethereum]] or from [[The Agoric Papers]]
        - This means virtually all sets & gets on an object will be async, except for operations performed within the object itself.
- This has some implications for modern UI development.
    - Using tools like [[CapTP]], a front-end may get a "remote proxy" reference to some objects that are on the backend.
        - This will be a language-native object, but If you assume a program that may be scaled across machines and processes, then interactions between objects must be async first ([[The Actor Model]])
        - [[CapTP]] JS currently has some additional restrictions regarding the structure of objects it passes
            - All references passed over [[CapTP]] are either [[record]]s or [[interface]]s.
        - Reason as explained by [[Michael Fig]]
            - It's because "records" (pass-by-copy) are immutable data that can be sent over the wire, but "interfaces" (pass-by-presence) are not sent over the wire, but can be called over the wire.  If we mix the two, we need to be very careful about which parts can actually be copied and which parts can't.
            - I don't see that there would be a lot of round trips: you can do a~.foo(1, 2, 3)~.bar~.baz('def')~.[2] which pipelines nicely even though it refers to both "records" and "interfaces".  The equivalent is E.G(E(E.G(E(a).foo(1,2,3)).bar).baz('def'))[2].  Of course, you can capture any of the intermediate expressions and fan out at your leisure.  Can you give an example of what would cause a round trip?
    - React, Elm, and others have popularized the reactive/unidirectional data flow style of programming. Is this pattern compatible with [[object capability (ocap)]], or [[CapTP]]?
        - [[Kris Kowal]] believes this is a paradigm mismatch! In his words:
            - I think there’s a paradigm mismatch between redux and captp. You could certainly make it work. The neat thing about redux is that it ensures the state changes are transactional, serializable, and just happen to be rewindable as a consequence, but at the expense of expressivity. The redux model forces you to serialize everything and for every state transition to fit in a single event. With CapTP, you can keep encapsulation capture some state in closures.
            - If I were doing both though, I would surface an interface that’s driving the redux state machine, not the redux state itself.
            - With that design methodology, your state machine driver interface would end up having a method for every edge in the union of state transition types.
            - I think that would gradually lead you away from capturing all state with redux. You might start decomposing that union object into different objects for each state, where each method returns an object corresponding to the state after the transition. That would allow for some divergence, for good and ill.
        - The root of each React app gets a state object, which is distinct from its actions. This could be considered similar to how [[CapTP]] JS currently has some additional restrictions regarding the structure of objects it passes.
        - Since If you assume a program that may be scaled across machines and processes, then interactions between objects must be async first ([[The Actor Model]]), the [[CapTP]] methods would only be useful via a dispatch type function, and not a synchronous [[redux]] reducer.
            - This implies a necessary separation between UI (local) state and remote reference representation.
            - Could there be a set of tools that simplify that potentially very common set of patterns?
                - A remote object with lots of remote properties and methods, all of which are async, and which define a significant portion of the interface.
                - The various loading/loaded/error states that are inherent in the most common patterns that are there?
                - Common patterns
                    - Properties
                        - get()
                            - loading
                            - loaded
                            - error
                        - set()
                            - setting
                            - set => updated value
                            - error
                                - unauthorized
                        - subscribe()
                            - updates emitted
                    - Functions
                        - Tend to be bespoke, hard to generalize.
                    - Read-only data
                        - Tend to be static, no interaction needed.
                - Even if the only common interactive pattern was regarding remote Properties, and everything else was functions or read-only, there would probably be some significant code-reuse and convenience to gain from some framework tooling.
        - An approach to a [[React]]//[[CapTP]] framework
            - We customize [[CapTP]] to allow mixed-interface-record objects at its marshall layer.
                - Rejecting the challenges of how [[CapTP]] JS currently has some additional restrictions regarding the structure of objects it passes
            - Mutable properties are always exposed as async Properties objects.
            - Objects arrive at the UI as a mixture of state and async functions.
            - Ideally, this object can be "consumed" by the UI library:
                - Since The code organization fundamentally represents units that may be shared, the objects received should represent convenient units for displaying data and interactivity, too!
                - This could eliminate the need to write redux "selectors", as the relevant functions are already collected with the relevant readable state.
                - If we wanted this to "just work" with Redux, we would need to make a library that did some tricks for us
                    - Filter out the functions from the data.
                    - Pass the data in as branches in a redux state.
                    - Keep the actions... available? Maybe just passing the relevant object into the component alongside the state? Weird to separate the "static state" from the "API shared" state, but I guess the point is the redux state can include exclusively local values.
                    - We might even include some helpers to more easily use our Properties objects with redux. Maybe we auto-generate some dispatcher functions or something.
