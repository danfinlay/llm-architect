- As opposed to [[overt channel]]
- As described by [[Mark Miller]], later in his words in [[A Taxonomy of Security Issues]]
    - Non-overt channels divide into [[side channel]] or [[covert-channels]] based only on the intention of the code or agent emitting the information. If Alice intended to leak the information to Bob, it is a covert channel. If Alice was coded with no such intention, then it is a side channel. It is much easier to defend against side channels than defend against covert channels. It is no easier to be invulnerable to side channels than covert channels. Seems paradoxical. By "defend" I mean imperfectly. By "invulnerable" I mean perfectly. Any misbehavior that Alice might engage in intentionally, she may engage in innocently. The probability distributions differ, but not the line between possible and impossible.
    - [The non-overt side of the weakref](((y-YVJQcgk))) is a great example of a non-overt channel that has nothing to do with timing. Whether Bob can measure duration has no bearing on whether he can read the signal that Alice send him though the gc system. That's why the [[WeakRef]] proposal was careful to quarantine the power to create a WeakRef as a separately deniable and virtualizable power not reachable from the shared primordials. So 1) Bob can be denied the ability to create a weakref. And 2) Bob can be given a weakref instance pointing at foo but still be denied the ability to create weakref instances pointing at anything else.
    - So our least authority linkage [[principle of least authority (POLA)]] module policies should by default deny both the ability to measure duration and the WeakRef constructor. The [[Secure EcmaScript (SES)]] whitelist of implicitly shared primordials omits both of these.
    - Non-overt channels lurk in the differences between what the spec requires a platform to do, and what a platform actually does. Say we are only concerned about correct platforms --- those that do everything the spec requires them to do. Then these channels exist only to the degree that the spec is non-deterministic --- that it allows some leeway of what the implementation actually does within the choices left open to it by the spec. A deterministic spec is one that has no such leeway. But I/O, duration, etc, are inescapable sources of leeway. [[E (Language)]] had "[[loggable fail-stop non-determinism]]". Let's start with [[loggable non-determinism]]. 
    - Loggable non-determinism means that the only sources of non-determinism were powers --- ocaps that were not provided by default, like I/O, [[WeakRef]], and sources of duration. If Bob runs as code confined by Alice, then Alice is in a position to log all inputs to Bob such that Bob cannot escape deterministic replay. Bob can't tell if this is the first time he's running and receiving live inputs, or being replayed from logged inputs. [[SwingSet]] treats [[Secure EcmaScript (SES)]] as a language with only loggable non-determinism and replays vats on that basis. See https://github.com/Agoric/agoric-sdk/issues/1852 for some example issues that arise.
    - So [[loggable non-determinism]] both enables replication and replay needed for chains, but also closes off the possibility of other non-overt channels. The logged inputs may still contain overt subliminal channels, such as stegonography in the low order bits of jpg images. But Alice only needs to worry about these in inputs she chose to provide.
    - I mentioned that [[E (Language)]] had [[loggable failstop non-determinism]]"and explained [[loggable non-determinism]] above. Like virtually all language specs, the E spec was silent about when computation would run out of memory. Two correct E implementations driven from the same overt inputs would deterministically do the same thing as long as neither ran out of memory. But one may run out of memory at some step where the other does not. Unlike JS and most languages, in E, running out of memory was immediately fatal to the vat (see https://github.com/tc39/proposal-oom-fails-fast ), ensuring that all computations that complete successfully must be in deterministic agreement. This is fail-stop non-determinism.
    - This raises another taxonomy breaker: The [[anthropic [[side channel]]]]. (This is distinct from the [[termination channel]] in the [[information flow]] literature, though that is interesting as well.) Say that Alice and Bob are both in a vat but not supposed to be able to communicate. Say that Alice at some point may or may not allocate a huge amount of memory. With knowledge of the implementation, Alice and Bob might know this would cause the system to run out of memory at some future time, say before Bob would have gotten control. If Alice does this, the vat is immediately terminated, Bob never receives control, and so Bob is not in a position to infer that Alice did this. However, if Bob does receive control, then he knows that Alice did not do this. "If I am alive, then Alice decided to let me live." Where the [[WeakRef]] communicated an amount of overt information that was more than zero overt bits but less than one bit. This anthropic side channel communicates more than zero non-overt bits but less than one bit.
    - That's all. I really need to pull all of this together into an article to counter the "[[Meltdown]] [[Spectre]] oh no fine grain security is impossible" crowd.
