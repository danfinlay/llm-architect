- By [[Tyler Close]]
- [Full Text](https://agoric.com/papers/acls-dont/abstract/)
    - {{pdf: https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2Fcapabul%2FYwx7cfJgBW.pdf?alt=media&token=5c2de40b-b557-4c44-a51d-64218552f1e9}}
- Notes
    - Intro: [[Access Control List (ACL)]] security has fundamental flaws
        -  Related to interactions with more than two parties
            - These kinds of interactions are exceedingly common on the web.
        - Widely documented in the literature but their nature has not been identified before now.
        - Former research focused on injecting logic into another context to be executed by that context's authority.
            - [[buffer overflow attack]]
            - [[SQL Injection]]
            - [[Cross Site Scripting (XSS)]]
        - A new category does not fit that mold that doesn't require injecting code into another program's logic.
            - These attacks can happen despite proper [[Access Control List (ACL)]] configuration.
            - The nature of an access matrix
            - The flaw of the ACL in the access matrix
            - Examples
                - [[clickjacking]]
                    - an attacker may start a web-cam recording, though no one but the computer’s user is supposed to be allowed to do that.
                - [[Cross-Site Request Forgery (CSRF)]]
                    - An attacker may successfully send a buy request to a victim's stock trading app, even though only the owner of the account is supposed to be able to.
    - Example [[Access Control List (ACL)]] usage
        - ![](https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2Fcapabul%2F6FA_vfeaxW.png?alt=media&token=9faf17e3-56be-40b7-a00e-b9aad8f87709)
        - a message consists of an identification of the sending process followed by an arbitrary amount of data.
        - User invokes a call on the compiler script, passing it path strings to the input file and the desired output location.
            - The system checks that the user has permission to call the compiler.
            - Checks down the A© of the access matrix, finding A(U, c, call), and so the access check passes.
        - The compiler sends the system a read message for the requested input file path.
            - The system checks if the sender (compiler) has permission to read the requested file.
            - The system fonds A(C, m, read) and it succeeds, so the file contents are returned.
        - The compiler sends a log entry to the log file.
            - The system verifies A(c,l,write) before proceeding, and permitting the log file addition.
        - Sounds like a setup for the [[confused deputy]] problem.
    - Example [[object capability (ocap)]] usage
        - a message consists of a list of permissions and an arbitrary amount of data. Each permission in the list is selected by the message sender, choosing from its held permissions. The selected permissions are added to the message by the system and therefore cannot be forged.
        - ```typescript
interface Message {
  permissions: Permission[];
  data: any;
}```
        - The user executes the vendor provided compiler.
            - This execution adds a new row and column to the access matrix. 
            - The compiler has `write` access to `log.txt`
        - The user sends a `compile` message to the compiler, specifying the permission to read the input source code file and permission to write the output code file.
            - The user's reference monitor constructs the message, copying the specified permissions from row A(u) of the access matrix.
        - "it’s more accurate to think of the Compiler as directly wielding the permissions received from the User, rather than having its own independent permissions."
        - The compiler compiles, and invokes the user's provided `write` permission to `a.out` to write the output.
        - The compiler then appends some log output to `log.txt` using the `write` access it was granted by the vendor.
        - The vendor may then inspect the `log.txt` file with its `read` access.
    - [[confused deputy]] attack
        - In the above examples, both ACLs and Ocaps work the same.
        - Consider the final access decision, to `write` to `a.out`
            - In the capability example, the reference monitor looked up the user's authority that was provided to the program to grant permission over the file.
            - In the ACL example, the reference monitor looked up the compiler's own access over the `a.out` file.
            - In another scenario, this distinction could cause a [[vulnerability]].
        - A different scenario
            - The user is an attacker
            - The user sends the compiler the message `compile('main.c', 'log.txt')`
            - The text string `log.txt` is sent by the user, and becomes the value for `target_file` provided by the compiler in its own code of `write(target_file, compiled_code)`
            - At this time, the reference monitor check's the compiler's access to `log.txt`, which it has write access to, and so the user has effectively obtained the privilege of writing to the `log.txt` file (albeit limited to the result of a compilation, but it could still wipe logs!)
    - ACLs don't authorize correctly
        - [[setuid executable]]
            - May be a reflexive alternative here, but no individual agent's authority is actually correct to embody the entire program's behavior over its lifecycle in the compiler scenario.
    - 
