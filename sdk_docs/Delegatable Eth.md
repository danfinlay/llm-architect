- A toolchain for adding general purpose [[counterfactual]] [[transitive [[delegation]]]] to any [[evm]] contract
    - An attempt to realize the usability and security powers of [[[[Ethereum]] [[object capability (ocap)]]]]s while also allowing as much as possible to be published off-chain to reduce gas costs for users.
    - [[power sharing]]
- Links
    - [Code on GitHub](https://github.com/delegatable/delegatable-sol)
    - https://delegatable.org
- [Premiere blog post](https://mirror.xyz/0x55e2780588aa5000F464f700D2676fD0a22Ee160/pTIrlopsSUvWAbnq1qJDNKU1pGNLP8VEn1H8DSVcvXM)
- Twitter threads
    - [Premiere Thread](https://twitter.com/danfinlay/status/1532025204028735488?s=20&t=)
        - https://twitter.com/danfinlay/status/1532025204028735488?s=20&t=
    - [Use cases thread](https://twitter.com/danfinlay/status/1533813647868239872?s=20&t=7GiG7h7q-8ehJMtbyZOAXA)
        - https://twitter.com/danfinlay/status/1533813647868239872
- Delegatable Eth (slides)
    - Problems with Ethereum today
        - Transactions all require eth, which puts up a market barrier to every first time user.
        - While there's a concept that counterfactual transactions are good, there is no coherent framework for what can be counterfactual and what must not be.
        - Sending to another user requires they have an address already, which further impairs engaging new users.
        - Transactions are not trivially readable (despite [[4byte.directory]], and [[Tx Insight]]). (at inversebrah)
        - Transactions get stuck behind each other, thanks to the nonce queue. An urgent transaction can get clogged behind a less urgent transaction.
        - Assets tend to be stuck in high-value accounts, and just connecting those accounts to the internet can be a stressful experience, because one mis-click can mean great loss.
        - Users end up re-using keys across devices, meaning they increase their attack surface with each new device, instead of preserving the [[principle of least authority (POLA)]].
        - Each transaction involves its own signature, which is both tedious to the user and needlessly expensive in gas. cc [[approvals.wtf]]
        - Existing access control policy systems are weak.
        - Most contracts end up implementing their own ad-hoc delegation system for each kind of authority, if any (tokens, NFTs, vote delegation)
        - These delegation systems can leave holes in the spec that leave users consistently exposed, like how ERC-1155 grants allowances on a per-contract basis, not a per-NFT basis, creating a huge scam vector.
        - Apps that want to incrementally onboard end up creating burner wallets that are hard to migrate off of, or they have a huge up front onboarding burden to start with a "real" wallet.
        - UBI projects like [[Circles UBI]] and [[Trustlines]] require bootstrapping adoption with adoption of new currencies, and use a transaction for every trust act, making it expensive to trust and grow the social collateral network.
    - Ideal blockchain experience
        - Readable transactions, even without a network connection.
        - Transactions that don't require gas.
        - Assets that can be sent to a user who doesn't even have an account.
        - Wallets that can prove what you have without a centralized index.
        - User devices that can be granted just the exact allowances that the user wants to permit to that device (or person), like a spending allowance, or 2FA authentication.
        - Apps could initialize a user with a burner account that could later delegate its authority to a higher security account.
    - Delegatable eth
        - How this one works
            - A simple solidity class that any contract can easily inherit from to gain its benefits.
            - Uses [[[[EIP 712: signTypedData]] v4]] for human-readable interactions, even by signers that have no internet connection.
            - Users can sign delegations to any other address for any function they can call on the parent contract.
                - These delegations can add arbitrary restrictions as [[caveat]]s.
                - Holders of these delegations can themselves sign delegation messages, without even needing an on-chain transaction.
                - Users who have signed delegations can invalidate those delegations by submitting a [[revocation]] message to the blockchain to block it.
            - Users can sign invocations to compatible contracts.
        - Demo/code tour 
            - A contract that inherits Delegatable
            - The test that interacts with that contract
            - The types that were involved
            - The main contract, if interested
        - What this could enable
            - Issuing allowances and permissions is free.
            - Issuing tokens and NFTs is free.
            - Yes, every slack react could be an NFT for free, and could imbue on-chain privileges.
            - Fees are only on transfer or revocation.
            - Users are trustlessly storing the data that grants them authority, allowing highly responsive but low-trust client-side custody.
            - Issuing streaming payments is free.
            - Sending someone a payment can be done as a link. They don’t need an address yet. (I advised [[Linkdrop]])
            - A referral commission can be added on top of any referral link, enabling [[incentive trees]]. (Everyone gets credit for their recommendations)
            - Implied counter-strategies for [[Miner Extractible Value (MEV)]]: Any offer can be easily and arbitrarily confined to permitted in-group members.
            - You could build a Circles style UBI network but with no transaction fees except on redemption, and backed by existing currencies to help bootstrap it.
            - Delegate what you want to an app, and let it stop nagging you for confirmations.
            - DEX users could approve asset managers (with no additional work from the DEX team)
            - User could add their own time-limit to an offer, even if the dapp didn't support it.
            - Governance systems all get liquid democracy "for free".
            - Airdrops could distribute the airdrop authority widely yet securely, like a chain of circuit breakers. Optimism style iterative airdrop? How about infinite recursive continuous airdrops of thanks?
            - Invite-tree special events
        - Some hackathon project ideas
            - [[WETHA]] / delegatable token wrapper
            - [[MobyMask]]
            - [[Circles UBI]] type mutual credit system
            - [[Decentralized Support]]
            - [[incentive trees]] for spreading access to a product
            - [[web3 of trust]] tx data comprehension
            - Put a [[ganache]] vm in the wallet so the wallet displays the "potential" state of the chain, the sum of these un-submitted messages.
        - Future
            - Goals
                - Repaying a relayer for gas (sending eth from a signature). May need [[[[EIP]] 3074: Delegated Invocation Contracts]].
                - Re-implement the proofs as [[zero-knowledge proofs]].
            - Possible Changes to Consider
                - Could [[offer safety]] be achieved as a form of caveat? Would be a strong proof of its ability.
                - Could a multisig be defined as a caveat? Would require an extra field for invocations, "caveat satisfaction" or something.
                - Maybe add a note field for conveying the intention of a delegation.
                - MetaMask changes
                    - Allow signing [[EIP 712: signTypedData]] for any network while connected to any network.
                    - Show [[pet name]]s whenever possible in EIP712 confirmations.
- Video explanations
    - [Video: Introduction (~1 hour)](https://www.crowdcast.io/e/cypherpunk-2022-workshop-series/13)
    - Delegatable meets [[Unlock Protocol]] [on YouTube](https://www.youtube.com/watch?v=Sh1-epThZV0)
        - {{youtube: https://www.youtube.com/watch?v=Sh1-epThZV0}}
- Enables
    - Any contract to delegate any [[power/capability]] it has to another person or contract.
    - Easy reasoning about the security around given methods.
    - Arbitrarily long chains of [[delegation]]. 
    - On chain transactions to be only needed for [[invocation or [[revocation]]]].
    - Arbitrary [[attenuation]] with each delegation.
    - Contract authors never need to write their own allowance or [[EIP 2612: DAI_v2 style permit()]] type methods, all methods would get allowance and [[counterfactual]] allowance methods for free, and those allowances could themselves be recursively delegated.
    - A clean separation between actions that must be on chain vs actions that do not need to be on chain, generally only [[invocation or [[revocation]]]].
    - Developers do not need to implement any additional [[access-control security]], as this sort of [[capability based security]] can emulate anything that can be defined as an [[Access Control List]].
    - Attenuator 
        - Ideas to implement
            - Allow listed methods
            - Expiration time
            - Total token (parameter) allowance
            - [[streaming payment]]
            - Valid target parameter range
            - Valid target parameter value
            - Gas relay reimbursement (with limit)
            - Ether allowance
- Gas analysis (pre [[[[EIP]] 4488: Reduce cost of [[calldata]]]])
    - Revocation cost 66k gas: https://goerli.etherscan.io/tx/0xfe043c2934106e59cd4b658aae53f414279beef66e290bde5b9ebd973c575379
        - 740 bytes of calldata
        - calldata cost of `19088` gas
        - `4440` gas after [[[[EIP]] 4488: Reduce cost of [[calldata]]]]
        - about 25% off the price of calldata here.
    - Batch of 3 reports from a tier 1 member was 223k gas, or 74k gas per report: https://goerli.etherscan.io/tx/0x005313d17da8f5aa2c886d1d98507cc6a6fa322d0c01e3a5ad7c37fdfcf20ab4
        - 3204 bytes of [[calldata]]
        - Assigned the calldata to `c`
        - `let totalCost = 0;`
        - `while (c.length > 0) { let byte = c.substring(0,2); if (byte === '00') { totalCost += 4 } else { totalCost += 68 }; c=c.substring(2); }`
        - totalCost of calldata was 50384 gas.
        - Post [[[[EIP]] 4488: Reduce cost of [[calldata]]]] would be `9612` gas, so a reduction of ~40k gas.
    - A basic token transfer (tether): 63k gas: https://etherscan.io/tx/0xf25bab09acccd3f4870953655090105587cd1085eb05cbf810b5c2f958e6d8d0
    - A second tier invitation reporting 2 phishers at once cost 193k gas: https://goerli.etherscan.io/tx/0xb2524b33320a98f2398a54b5ac30c31bfd54ee05c84a826a722c410f8426d635
    - Tier 1 invite of 20 people = 1.8 million gas, or ~90k/report https://goerli.etherscan.io/tx/0x7d8f0e21c7cc245167dfc10a8281e1bcc8fd0ab01a48cc209bce5cdbf2081a57
- Design
    - A standard interface that can be added to any [[smart contract]], including a [[contract account]].
    - Allows signing revocable [[delegation]] messages off-chain.
    - Allows holders of delegation messages to present that message as the authority needed to invoke its specified function.
    - These delegation messages themselves allow chaining together with additional [[delegation]] messages.
    - The [[delegation]] messages can include references to any number of [[[[Delegatable Eth]] Attenuator]] contracts, along with parameters to pass to that attenuator.
        - This means that while new types of [[attenuation]] cannot be [[counterfactual]], once an [[[[Delegatable Eth]] Attenuator]] is published on chain, anyone should be able to use it to attenuate a delegation message.
    - Avoids using signed arrays, since [[EIP 712: signTypedData]] v4 has a flawed array encoding. So rather than wait for v5, I currently recommend nesting structs instead of using arrays. Could also have an array of signed structs as long as the array itself isn’t signed.
        - An early draft of this used arrays to build a sort of [[n of m multisig]] into the delegation struct, but when trying to eliminate arrays I also noticed that a multisig could be built into a form of caveat, also. If only the multisig caveat were desired as authorization, the recipient key could be transmitted alongside the delegation message.
        - Since we cannot have an array of caveats, in this design if many caveats are needed, then a "batch caveat" caveat must be created. I like this because it lets us bump more complexity out of the initial design.
    - Revocability can be built in as a type of optional caveat.
        - A revocable caveat would be a contract that allows the author to pre-commit to the signed message in some way, maybe by committing to a nonce that is stored uniquely per user.
    - Could use [[multi-nonce]] for its [[replay protection]].
- Builds on ideas from previous approaches
    - [[counterfactual social collateral cash]]
    - [[[[Ethereum]] [[object capability (ocap)]]]]
    - [[Counterfactual WebCap Wallet]]
        - Like it, this aims to allow chains of delegation entirely off-chain, only requiring redemption & revocation on-chain.
        - Unlike that one, instead of relying on [[[[EIP]] 1014: CREATE2]] to define delegators as chained individual counterfactual contracts, this one takes a different approach, where [[caveat]]s are defined instead as a pointer to a parameterized enforcer, as discussed below.
    - [[[[[[EIP]] 3074: Delegated Invocation Contracts]] Transitive Delegation Pattern]]
        - The general shape of its `TransitivelyDelegatableInvoker` format
        - The notion of parameterized caveat_enforcer?: addresss.
            - By using on-chain caveat_enforcers, we can [avoid the need](https://github.com/gnosis/safe-contracts/issues/239) for [[multi-nonce]] or [[[[EIP]] 1014: CREATE2]] support in [[[[Gnosis]] SAFE]].
        - Avoids relying on [[[[EIP]] 3074: Delegated Invocation Contracts]], since the proposal has been postponed, which means this would only be available to compatible contracts, instead of to all accounts (including [[externally owned account (EOA)]]s).
    - [[Stateless SAFE Cap]]
    - [[gnosis safe attenuator]]
- [Useful prior architecture notes](((jOc-vjpac)))
    - Distinctions
        - We shouldn't need `owners`, if we simply interpret any valid signed message as if it came from that signing address. Then any owners inherently get any of their benefits, and any other authorized users inherently get any of their benefits as well.
- Planning
    - {{kanban}}
        - to do
            - Formal audit?
            - V2: [[Delegatable 4337]]
        - In progress
        - done
            - fix erc-20 allowance caveat
            - convert tests to use the js-utils library
            - publish the latest js-utils lib, with "memberships"
- Open questions
    - Can [[[[[[Gnosis]] SAFE]] guards]] be used as the [[[[Delegatable Eth]] Attenuator]]?
        - Ideally they can be "publish once", and then just [[DELEGATE_CALL]]'ed to get their behavior but without deploying additional copies for other delegations.
        - Possibly not: Guards seem to be made to be deployed once per use, and definitely are not "passed parameters on invocation". Their parameters seem to be encoded in them at deploy time.
    - Is there a way to delegate to a counterfactual multisig in this scheme, with minimal changes?
        - See [[[[counterfactual]] [[Delegatable Eth]] contracts]]
    - Is there a way to encode "terms" in a way that could be open-ended (per [[[[Delegatable Eth]] Attenuator]]), but still human readable? Seems like having `bytes` that can vary by attenuator is the most open-ended solution, but loses readability. Having a string that is parsed is a more expensive but human readable option.
    - Can [[offer safety]] be achieved as a [[caveat]]?
