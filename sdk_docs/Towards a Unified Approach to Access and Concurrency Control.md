- The doctoral thesis of [[Mark Miller]]
- Dedicated to the number [[3469]] and the letter “E”.
- [Full text](http://www.erights.org/talks/thesis/markm-thesis.pdf)
- Excerpts & Summary
    - 2: Approach and Contributions
        - Unattenuated authority
            - ![](https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2Fcapabul%2FSuGJ7yN1W6.jpeg?alt=media&token=ffc34d51-3014-478f-8799-a177f49acb92)
        - Attenuated authority
        - Distributed access control
            - objects are aggregated into persistent process-like units called [[vat]].
            - [[pluribus]] is the cross-[vat]([[vat]]) cryptographic protocol of the [[E (Language)]] that allows unforgeable reference sharing.
            - “Our overall system consists of object-capability islands sending messages to each other over a cryptographic capability sea. A contribution of this section is to introduce a unified account of access control in such a mixed system.“
            - [[E (Language)]] has two forms of invocation operator: “.”, as in `alice.bob(carol)`, and “<-“, as in [[Eventual Send]], so `alice<-bob(carol)`.
        - Distributed Concurrency Control
            - [[E (Language)]]’s concurrency is based on communicating [[event loops]].
            - Each [vat]([[vat]]) has
                - a heap of objects
                - a call-return stack
                - a queue of pending deliveries
                - a single thread of control
            - Concepts
                - [[promise]]
                - [[near reference]]
                    - the form of reference familiar from conventional sequential non- distributed object programming. A near reference is a local reference to a resolved target. In other words, a near reference starts and ends in the same vat, and it knows which target object it should deliver messages to. A near reference conveys both immediate-calls and eventual-sends, providing full authority to invoke its target. Only near references convey immediate-calls, so objects in one vat may not immediate- call objects in another vat. Thus, each turn implicitly has mutually exclusive access to all state to which it has synchronous access. No explicit locks are needed or allowed.
                - [[far reference]]
                    - a vat-crossing reference to a resolved target. So long as its target’s vat is reachable, a far reference conveys eventual-sends to its target. A far reference thereby provides only the authority to enqueue pending deliveries in its target’s vat’s queue, to be delivered to its target in separate isolated turns. An eventual-send is non-blocking—the sender cannot block its vat’s thread waiting for a response. Thus, conventional deadlocks cannot occur.
                - [[broken reference]]
                    - occurs as a result of a problem. If a turn terminates by throwing an exception, that breaks the promise for the turn’s result. A partial failure—a network disconnect or crash—will break vat-crossing references. Once a reference is broken, it stays broken. Inter-vat connectivity can be regained using [off-line capabilities]([[offline capability]])
                - [[offline capability]]
                    - provides persistent access to the object it designates— it allows one to obtain a new reference to this object. One form of [[offline capability]], a URI string, can be transferred over out-of-band media in order to securely bootstrap initial connectivity.
            - Introduces the concept of the [[promise]]
        - [[Promise Pipelining]]
            - Machines grow faster and memories grow larger. But the speed of light is constant and New York is not getting any closer to Tokyo. As hardware continues to improve, the latency barrier between distant machines will increasingly dominate the performance of distributed computation. When distributed computational steps require unnecessary round trips, compositions of these steps can cause unnecessary cascading sequences of round trips.
                - Figure 2.5: Promise Pipelining.
            - Related prior work shows how, in asymmetric client-server systems, distributed func- tional composition can use promise pipelining (Figure 2.5) to avoid cascading round trips. In Chapter 16, we show how to extend this technique to symmetric peer-to-peer systems.
        - Delivering messages in [[E-ORDER]]
            - Various distributed systems provide useful constraints on message delivery orders, reducing the cases programmers must face. In Chapter 19, we show how FIFO and weaker orders fail to enforce a needed access control restriction: FIFO allows Bob to access Carol earlier than Alice expects. By the conventional taxonomy, CAUSAL order is the next stronger order. If enforced, it would safeguard Alice’s expectations. However, CAUSAL order is too strong to be enforceable, purely by cryptographic means, between mutually suspicious machines.
        - Emergent Robustness
    - 3: Fragile Composition
        - Within today’s dominant paradigms of composition, programmers are faced with a dilemma, which we illustrate as the diagonal on Figure 3.1. At upper left, the price of enabling cooperative interaction is that destructive interference is enabled as well. In reaction to the resulting hazards, various mechanisms have been introduced into programming languages and op- erating systems to express and enforce perimeters that more safely separate components. Naively applied, they also prevent cooperative interaction. Manifestations of this dilemma appear in both access control (Figure 3.2) and concurrency control (Figures 3.3 and 13.3). Strategies for dealing with these are the subjects of Part II and Part III of this dissertation.
        - ![](https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2Fcapabul%2FMn_38jrxra.jpeg?alt=media&token=2546effb-8863-45e1-8c7b-a7b7352e6183)
        - Conventional access control systems force a trade- off between statically granting a program enough authority to do anything it might need to do versus denying it authority it could use to cause harm. By granting authority dynamically as part of the request, we can provide just that authority needed for that request. Since “least authority” includes ade- quate authority, least authority is as high on the vertical axis as needed for the requested functionality. The horizontal line with the question mark rep- resents the design question: How much safety may we achieve without loss of functionality?
        - ![](https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2Fcapabul%2FzoapNjaPBY.jpeg?alt=media&token=b21b3b20-41a8-4174-9966-ad0153188bea)
        - In the presence of concurrency, correct programs must prevent those interleavings which threaten consistency while allowing all those needed for progress. In practice, the conventional approach of making components “thread-safe” forces a tradeoff between confidence that consis- tency is maintained versus confidence that progress will continue. The event- loop style allows both requirements to be met with confidence.
        - Currently under Unix, both cp and cat, like Solitaire, run with all your authority. But the least authority they require to copy a file differs substantially. Today’s widely deployed systems use both styles of designation. They grant permission to open named files on a per- user basis, creating dangerous pools of excess authority. These same systems dynamically grant an individual process access to a resolved file descriptor on a per-invocation basis. Ironically, only their support for the “cp” style is explained as their access control system. Shells supporting narrow least authority [Sea05] differ from conventional systems more by the elimination of the “cp” style than by the elaboration of the “cat” style.
        - Following [[Carl Ellison]]’s usage [Ell96], we refer to the “cp” style of designation as “[[name-centric]]” and the “cat” style as “[[key-centric]].” In name-centric systems, names are generally assumed to be human readable, like the filenames in our cp example or DNS names in Ellison’s. Name-centric systems pass names to communicate designations, requiring a shared namespace. In key-centric systems, keys are opaque and unambiguous, like the file descrip- tors in our cat example or cryptographic keys in Ellison’s. Key-centric systems pass keys to communicate designations. In key-centric systems, names are bound to keys in name- spaces local to each participant, such as the user’s file system in our example. We return to Ellison’s distinction in the related work section at the end of this chapter.
        - Programming languages based on lexical naming [Chu41] and references (including ob- ject [GK76, HBS73], lambda [KCR98, Mil84], and concurrent logic [Sha83, Sar93, RH04] languages) generally follow the key-centric style, combining designation and access as sug- gested by the cat example above. Names are evaluated in their caller’s namespace to a value, such as a reference to an object, which is then passed as an argument to the callee. The callee doesn’t know or care what the caller’s name for this reference is. By passing this reference as a particular argument of a particular call, the caller both tells the callee what object it wishes the callee to interact with as part of this request, and provides the callee the ability to interact with this object. The changes to these languages needed to support least authority consist more of eliminating their support for the name-centric designation rather than elaborating their support for the key-centric designation. Besides E, in related work (Part V), we visit several other examples of such languages.
        -  ![](https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2Fcapabul%2F0x-Z5Bpk-1.jpeg?alt=media&token=13dff781-8221-4132-aebc-c22a0175a630)
        - the more common experience, especially when composing large systems, is that this discipline forces programmers to make a tradeoff between bad choices ([[RH04]], [[Lee06]], [[Ous96]]]).
        - To understand this dilemma, Part III first presents the StatusHolder, a composable abstraction that is properly considered triv- ial among sequential object programmers. It then attempts, by successive refinement, to develop a thread-safe StatusHolder that is robustly composable under shared-state con- currency.
        - We will argue that an alternative discipline, communicating event loops ([[HBS73]], [[Agh86]], [[DZK+02]], [[ZYD+03]], provides a framework in which programmers can straightforwardly write programs that are both consistency-preserving and deadlock-free.
        - FIFO and weaker orders allow a race condition which violates a desirable access control property. E-ORDER, which is stronger than FIFO and weaker than CAUSAL (FIFO ≤ E-ORDER ≤ CAUSAL), satisfies all our constraints simultaneously.
        - Notes on related work on designation
            - This distinction between the two styles of designation explained above ([[name-centric]] and [[key-centric]]) has intriguing parallels in the philosophy literature contrasting two perspectives on naming. In Naming and Necessity [[Kri80]], [[Saul Kripke]] reacts against [[Bertrand Russell]]’s suggestion that names be regarded as “[[compact descriptions]],” arguing instead that names should be regarded as “[[rigid designators]].” Russell’s “compact descriptions” are similar in some ways to the widely shared names of name-centric systems. Kripke’s “rigid designators” are similar in some ways to the keys of key-centric systems. In other ways, Kripke’s rigid designators are like the local names which are bound to keys. Kripke’s causal account of how designations come to be shared is based on acts of pointing and communication, which have intriguing analogs to our notions of object creation, invocation, and argument passing.
            - Although it has long been understood that capabilities bundle designation with per- mission [[Lev84]], [[Norm Hardy]]’s [[confused deputy]] [[The [[confused deputy]]
(or why capabilities might have been invented)]] was the first to explain why these need to be bundled, and to point out other dangers that follow from their separation— dangers beyond the excess authority hazards explained above.
            - [[Carl Ellison]]’s [[Establishing Identity Without Certification Authorities]] [[Ell96]] contrasts these two naming philosophies as applied to the Internet as a whole. He shows how the Domain Name System and conventional uses of [[X509 certificates]] are [[name-centric]]: These systems attempt to create an Internet-wide shared hierarchical namespace of human meaningful names, like a conventional file system writ large. He contrasts this with [[key-centric]] systems like [[SDSI/SPKI]] [[EFL+99]], in which opaque cryptographic keys are the only globally meaningful designators, and all use of human readable names is rooted in the local naming environment of the entity employing the name. [[SDSI/SPKI]] is an offline certificate-based system. As with file systems or DNS names, human readable names are actually naming paths, for traversing paths through a graph starting at some root. However, in key-centric systems like SDSI/SPKI, the root at which this traversal starts is each participant’s own local namespace. The [[Client Utility architecture]] covered in Related Work Section 25.6 included an online protocol that also used locally rooted path-based names. In these key-centric systems, as in our cat example, humans use human readable names to securely designate.
            - [[Marc Stiegler]]s [[An Introduction to [[pet name]] Systems]] [[Sti05]] explains phishing as the inverse problem: How may designations be communicated to humans as human readable names, in a manner resistant to both forgery and mimicry? Our vulnerabilities to phishing are due to the name-centric nature of the Domain Name System. Stiegler explains [[Tyler Close]]’s realization that petname systems extend key-centric systems in a phishing resistant fashion. The local namespace of most key-centric systems provides a many-to-one mapping of names to keys. The inverse problem requires mapping keys back to names. The local namespaces of petname systems provide this backwards mapping. Close’s “Petname tool” [[Clo04a]] and [[Ka-Ping Yee]]’s “[[Passpet]]” are [[WebExtension]]s for phishing resistant browsing. Stiegler’s own [[CapDesk]] [[WT02]], [[SM02]] and Polaris [[SKYM04]], which we explain briefly in Part IV, use petnames for secure window labeling of confined applications.
            - [[Global namespace]]s create intractable political problems. [[Froomkin]]’s [[Toward a Critical Theory of Cyberspace]] [[Fro03]] examines some of the politics surrounding [[ICANN]]. In a world using key-centric rather than name-centric systems, these intractable political problems would be replaced with tractable technical problems.
    - 4: Programs as Plans
        - In the human world, when you plan for yourself, you make assumptions about future situ- ations in which your plan will unfold. Occasionally, someone else’s plan may interfere with yours, invalidating the assumptions on which your plan is based. To plan successfully, you need some sense of which assumptions are usually safe from such disruption. But you do not need to anticipate every possible contingency. If someone does something you did not expect, you will probably be better able to figure out how to cope at that time anyway.
        - When programmers write programs, they express plans for machines to execute. To formulate such plans, programmers must also make assumptions. When separately for- mulated plans are composed, conflicting assumptions can cause the run-time situation to become inconsistent with a given plan’s assumptions, corrupting its continued execution. Such corrupted executions likely violate assumptions on which other programs depend, po- tentially spreading corruption throughout a system. To program successfully, programmers use abstraction and modularity mechanisms to limit (usually implicitly) which assumptions must be made, and to structure these assumptions so they are more likely to mesh without conflict. Beyond these assumptions, correct programs must handle all remaining relevant contingencies. The case analysis burden this requires must be kept reasonable, or robust programming becomes impractical.
        - We describe the tenets of conventional object programming practice in terms of decomposi- tion, encapsulation, abstraction, and composition. We describe how programmers use each of these steps to organize assumptions.
        - [[decomposition]]
            - When faced with the need to write a program providing complex functionality, program- mers must subdivide the problem into manageable units. Emerging from the spaghetti-code software crisis of the 1960s [[Dij72]], programmers learned to practice hierarchical decompo- sition [[Wir71]], [[Mil76]], dividing each task into subtasks. To oversimplify a bit, each node in this decomposition tree was represented by a procedure which achieves its task partially by contracting out subtasks to the procedures it calls. Programmers would seek task divisions where the responsibilities of each procedure was clear, simple and separate.
            - With hierarchical decomposition, programmers could organize assumptions about which procedure was supposed to achieve which purpose. But there remained the issue of what resources each could employ in order to accomplish its purpose. Different procedures might manipulate common data in conflicting ways—the manipulations performed by one might disrupt the assumptions of another. So long as access to common data was undisciplined, assumptions about how the data was to be manipulated were spread throughout the code, and could easily conflict.
        - [[encapsulation]]
            - To avoid conflicting assumptions about data manipulation, programmers learned to package code and data together into modules and abstract data types [[Par72]], [[LZ74]], [[LSA77]]. For uniformity, let us refer to instances of abstract data types as objects. The code of each object still manipulates data, but the data it manipulates is now private to that object. When writing the code of such an object—when formulating a plan for how it will use its data to accomplish its purpose—the programmer may now assume that this data is not also being manipulated by other potentially conflicting plans. This discipline enables programmers to create systems in which a massive number of plans can make use of a massive number of resources without needing to resolve a massive number of conflicting assumptions. Each object is responsible for performing a specialized job; the data required to perform the job is encapsulated within the object [[WBM03]].
        - [[abstraction]]
            - When programmers carve the functionality of a system into subtasks using only hierarchical decomposition, each provider serves only the specific concrete purpose needed to contribute to its one client. Instead, programmers learned to create opportunities for reuse and poly-
            - An interface designed to serve the needs of only one client will not help reuse. An in- terface that exposes implementation details will not help polymorphism. A well designed interface serves as an abstraction boundary, simultaneously abstracting over the multiple concrete reasons why a client may wish to employ this service and the multiple concrete means by which a provider may implement this service. The interface represents the rel- atively thin and stable assumptions by which clients and providers coordinate their plans. It provides the “what” (stack) that insulates the multiple “why”s of client plans (parsing, reverse Polish arithmetic) from the multiple “how”s of provider plans (array, cons), and vice versa, so they are freer to evolve separately without disrupting each other’s assumptions.
            - 1 In this dissertation, we use the term “polymorphism” as it is used in the object programming literature: for late binding of message to method, allowing for runtime substitutability of different implementations of the same interface. For the concept ML programmers call “polymorphism” we use the term “parameterized types.”
            - morphism [[DN66]], [[Mey87]], [[Mey88]], [[GHJV94]], [[WBM03]].
            - abstract purpose (the classic example is a [[LIFO stack]]) that multiple clients can employ for multiple concrete purposes (such as parsing or reverse Polish arithmetic). The abstract purpose is represented by an interface or type, in which the message names (push and pop) indicate the abstract purpose they serve. For polymorphism, multiple concrete providers can implement the same abstract service in different concrete ways (indexing into an array or consing onto a linked list).
            - Once programmers have designed the abstraction boundaries needed to carve up the required functionality, their remaining planning problems are comparatively well separated. Since abstract interfaces stand between client objects and provider objects, these objects also stand between abstract interfaces. As provider, each object’s plan must be designed to contribute not to its client’s concrete plans, but to the abstraction of these plans represented by the interface it is charged with implementing. As client, each object’s plan should be based not on the concrete behavior of its providers, but only on the abstraction of their behavior represented by the provider interfaces it assumes.
        - [[composition]]
            - Abstraction boundaries help separate concerns, giving composition its power.
            - The use of abstraction boundaries explained above motivates only relatively static client- provider subcontracting networks. In a static reference graph, the payoff from reuse would still be clear: Parsing is very different from reverse Polish arithmetic, so their reuse of com- mon stack code provides a real design benefit. But polymorphism would be uninteresting: Since our example stack implementations all implement the same interface contract, they are semantically identical and differ only in efficiency. If all polymorphism were like our stacks, polymorphism would be a detail rather than a major tool of good object design. If the choice of provider were based only on efficiency, this decision would best be made at design time anyway, which would not require any runtime late binding mechanism. To un- derstand the power of polymorphism, we must see beyond static “client-provider” reasoning when describing how objects use each other’s services.
            - 
        - Related works
            - David Parnas’ On the Criteria to be Used in Decomposing Systems into Modules [Par72] explains why systems decomposed along data manipulation lines often hide complexity better than systems decomposed along chronological plan-sequence lines. The extensive literature on abstract data types (introduced by Liskov [LZ74]) shows how programming languages have leveraged these observations.
            - Of the extensive literature on object-oriented design principles, Bertrand Meyer’s Object- Oriented Software Construction [Mey88] and Wirfs-Brock and McKean’s Object Design— Roles, Responsibilities and Collaborations [WBM03] are particulary insightful. Design Pat- terns, Elements Of Reusable Object-Oriented Software [GHJV94] spawned a further exten- sive literature capturing, classifying, and analyzing particular arrangements making use of these object design principles.
            - Abadi and Lamport’s Conjoining Specifications [AL95] distinguishes the correctness issues which arise when decomposing a system into specialized components vs. those which arise when composing a system from reusable components.
            - Our explanation of object programming owes a debt to the plan-coordination literature in economics. Our explanation of encapsulation derives in part from Friedrich Hayek’s ex- planation of the plan-separation function of property rights [Hay37, Hay45, MD88]. Division of the society’s resources among the active entities enables the decentralized formulation of plans, based on mostly non-conflicting assumptions about what resources will be at each plan’s disposal.
            - Our explanation of abstraction boundaries derives in part from Ludwig Lachman’s ex- planations of the plan coordinating function of institutions [Lac56, TM06]. The concept of “post office” stands between all the reasons why people may want to mail a letter and all the means by which delivery services may convey letters to their destinations. The ab- straction boundary both separates these plans from one another’s details, and it provides for interactions so they can usefully coordinate.
            - Our explanation of composition derives in part from Mark Granovetter’s visual expla- nations of social connectivity dynamics [[Gra73]], [[MMF00]], where new relationships form as people introduce people they know to each other. With Granovetter’s permission, we refer to Figure 4.1 and similar diagrams as “[[Granovetter diagram]].”
    - 5: Forms of Robustness
        - Under what conditions will a correct program behave correctly? A program is a mathemat- ical object; its correctness is a mathematical question. As engineers, we care about what transpires when a program is run. We must examine the bridge from abstract correctness to desired behavior. If this bridge rests on flimsy assumptions, correctness is inadequate for robustness. This chapter distinguishes forms of correctness based on the structure of these assumptions, and examines how each contributes to robustness.
        - Although this chapter adapts some concepts from the formal correctness literature, we are concerned here more with conventional software engineering quality issues. A program is correct when it “meets its specification,” i.e., when it does what it is supposed to do. Formal correctness demands formal specification. However, even after decades of research and development on formal specification languages, the practical reality today is that most specifications are informal, and many are not even written down [DLP79]. Nevertheless, pro- grammers informally reason about the correctness of their programs all the time, and with some success [[Gut04]]. The formal correctness literature helps explain how programmers do so, and how they may do better: by applying informal (and psychologically plausible) adaptations of these formal techiniques. We close this chapter (in Section 5.8) with some thoughts on related areas in formal correctness.
        - 5.1: Vulnerability Relationships
        - 5.2 Platform Risk
            - Systems are built in many layers of abstraction. For purposes of analysis, at any moment we must pick a frame of reference—a boundary between a platform (such as a language or operating system kernel) enforcing rules of permissible action, and the set of all possible programs running on that platform, assumed able to act only in permitted ways [And72, NBF+80, SS87]. By program we refer only to code running on that platform, whose behavior is controlled by the platform’s rules. We implicitly allow all programs running on a platform to assume their platform is correct—their platform is in their reliance set [Tin92]. For incr, the natural frame of reference is to choose the C language as the platform, requiring correct behavior only if the C implementation behaves correctly. The relevant universe of programs consists of that code whose interactions with incr are governed by the rules of C, which is to say, all other C programs which might be linked together and run in the same address space as incr.
                - [[leap of faith]]
            - As we will see, distributed systems can support full decentralization. Each portion rests on a platform to which it is fully vulnerable, but different portions rest on different platforms. A fully decentralized system may have no central points of failure, such as a common administrator.
        - Because there is no isolation within the universe defined by the [[C language]], no robustness is possible. Everything is fully vulnerable to accident or malice by anything else within its universe. Each is a central point of failure for all. Correct code can only be expected to behave correctly when all other code in its address space is also correct.
        - 5.5 Defensive Correctness
            - If a user browsing pages from a webserver were able to cause it to display incorrect pages to other users, we would likely consider it a bug in the webserver—we expect it to remain correct regardless of the client’s behavior. We call this property defensive correctness: a program P is defensively correct if it continues to provide correct behavior to well behaved clients despite arbitrary behavior on the part of its other clients. Before this definition can be useful, we need to pin down what we mean by “arbitrary” behavior.
            - We define Q’s authority as the set of effects Q could cause. With regard to P’s correct- ness, Q’s relevant authority is bounded by the assumption that everything in P’s reliance set is correct, since P is allowed this assumption. For example, if a user could cause a webserver to show the wrong page to other browsers by replacing a file through an operating system exploit, then the underlying operating system would be incorrect, not the webserver. We say that P protects against Q if P remains correct despite any of the effects in Q’s relevant authority, that is, despite any possible actions by Q, assuming the correctness of P’s reliance set.
            - Now we can speak more precisely about defensive correctness. The “arbitrary behavior” mentioned earlier is the combined relevant authority of an object’s clients. P is defensively correct if it is cooperatively correct and protects against all of its clients. The focus is on clients in particular in order to enable the composition of correct components into larger correct systems. If P relies on R, then P also relies on all of R’s other clients unless R is defensively correct. If R does not protect against its other clients, P cannot prevent them from interfering with its own plan. By not relying on its clients, R enables them to avoid relying on each other
        - Because they enforce some isolation of access to memory, memory-safe languages can aspire to object-granularity defensive consistency. In E, as in most of these, fundamen- tal operations implicitly allocate memory, rendering object-granularity defensive progress unattainable. For example, any “proof” that an ML function terminates with a correct answer is subject to the implicit caveat “given enough memory,” which is a condition that any other ML function in that same address space can cause to be false.
        - Similarly, within E’s architecture, object-granularity defensive correctness is impossible. E objects are aggregated into process-like units called vats, explained in Chapter 7 and Section 14.1. Like a process, a vat is the minimum granularity to which resource controls could be practically enforced. With respect to progress, all objects within the same vat are mutually reliant. In many situations, defensive consistency is adequate—a potential adversary often has more to gain from corruption than denial of service. This is especially so in iterated relationships, since corruption may misdirect plans but go undetected, while loss of progress is quite noticeable.
        - When a system is composed of defensively consistent abstractions, to a good approxi- mation, corruption is contagious only upstream, from providers to clients [Tin92].
        - Full defensive correctness is infeasible in E even between directly communicating vats. An area for future research is to investigate whether per-client intermediate vats can guard an encapsulated shared vat in order to practically resist denial of service attacks [Sch06].
        - The “arbitrary behaviors” we are concerned about, since they include both accident and malice, are conventionally classified as “Byzantine faults” [LSP82]. However, we avoid that terminology because it is invariably associated with the problem of Byzantine fault tolerance: How to use redundant, unreliable, and possibly malicious replicas to do a single well-characterized job reliably [LSP82, CL02]. If all one’s eggs are in one basket, one should employ multiple guards to watch that basket and each other, so that an adequate number of honest guards can mask the misbehaviors of the other guards. This reduces the likelihood that any eggs will be lost. By contrast, the forms of defensiveness explained in this dissertation help isolate Byzantine faults, reducing the likelihood that all eggs will be lost. The two approaches are complementary. Ideally, robust systems should employ both. We return to this topic briefly in Related Work Sections 25.1, 25.2, and 26.8.
        - To give a more plausible account of how programmers informally reason about con-
        - formance to informal (and often inarticulate) specifications, we have divided specifications into purposes and hazards. Our notion of purpose derives from Daniel Dennett’s notion of intent in The Intentional Stance [Den87]. As Dennett emphasizes, an artifact’s purpose is not an objective property, but rather, a descriptive stance employed by observers for their own purposes, and so on. Sex provides an example of how hazards depend on purposes: When the purpose of sex is pleasure, pregnancy may be regarded as a hazard. To that person’s genes, the purpose of sex is reproduction and condoms are a hazard. Their plans conflict, not because of inconsistent assumptions, but because of conflicting intents.
    - 6: a taste of E
        - Like most “new” languages, little about E is actually novel. Most of its elements are drawn from prior language designs. The specific novel contribution of this dissertation is the state transition semantics explained in Part III and shown in Figure 17.1 (p. 124). The value of this contribution lies in its integration with other language features, so it is important to present a cohesive framework. In this dissertation, E serves as that framework.
        - This chapter briefly explains a subset of E as a conventional sequential object language. This dissertation will introduce other aspects of E as they become relevant. For a more complete explanation of E, see [[Sti04]].
        - 6.1 From Functions to Objects
            - Object computation can be understood as the sum of three elements [GK76, HBS73]: Objects == Lambda Abstraction + Message Dispatch + Local Side Effects
            - The remaining feature often thought to be defining of object-oriented programming is inheritance [Weg87]. Though we do not view inheritance as a fundamental ingredient of ob- ject computation, its widespread use in object-oriented programming practice motivates its inclusion in E. However, E’s reconciliation of inheritance with capability security principles [Mil04] is beyond our present scope.
        - 6.1.1 Lambda Abstraction
            - The call-by-value lambda calculus [Plo75] is a pure theory of nested function definition and application.
        - 6.1.2 Adding message dispatch
            - The most visible difference between a function and an object is that a function’s behavior is written to satisfy just one kind of request, and all calls on that function are forms of that one request. By contrast, an object’s behavior enables it to satisfy a variety of different requests (each with a separate method). A request to an object (a message) identifies which of these requests is being made. This is not a fundamental distinction—either functions or objects can be trivially built from the other in a variety of ways. As we will see, in E, objects are the more primitive notions, of which functions are defined as a degenerate case.
                - Note from [[Dan Finlay]]: We can construct a function in a way that it is able to handle many message types, like in the case of [[JSON-RPC API]], as an example of constructing one from the other.
            - Figure 6.2 shows the makePoint function which makes and returns point objects. From a lambda calculus perspective, makePoint is like makeAddr—it is a lexically enclosing func- tion that defines the variable bindings used by the object it both defines and returns. From an object perspective, makePoint is simultaneously like a class and constructor— both defining the instance variables for points, and creating, initializing, and returning individual points.
            - The returned points are clearly object-like rather than function-like. Each point’s be- havior contains three methods: getX, getY, and add. Every request to a point names which of these services it is requesting.
            - Some shorthands in this code need a brief explanation.
            - • “a + b” is merely syntactic shorthand for “a.add(b)”, and similarly for other expres- sion operators. As in Smalltalk, all values, including integers, are objects. Addition happens by asking one integer to add another integer. (As E’s robustness convention demands, this operation either returns the correct sum or visibly fails due to resource exhaustion.)
            - E’s “functions” are really objects with a single run method. In E, all values are ultimately objects, and all invocation is by message passing. So- called functions are just a syntactic shorthand.
        - 6.1.3 Adding Side Effects
            - Under the covers, each assignable variable is actually a distinct primitive variable-object, referred to as [[slots]]. By declaring var count, we introduce a binding from the name "&count" to a new mutable Slot object holding the current count. Writing a use-occurrence of count in an expression is like writing (&count).getValue(), asking the Slot for its current value. Writing count := expr is like writing (&count).setValue(expr), asking the Slot to remember the argument as its new current value. Slots serve the same purpose in E as do so-called “Ref”s in Algol-68 and ML.
        - Composites and Facets
            - For compactness of description, we often aggregate a set of objects into a composite. The three objects created together by each call to makeCounterPair form a [[lexical composite]]. Like an individual object, a composite is a combination of state and behavior. Like an individual object, the state consists of all of the variables within the composite. The behavior consists of all of the code within the composite, but here we have an important difference.
            - The behavior elicited by a message to the composite depends both on the message and on which object of the composite receives the message. Objects which may be referred to from outside the composite, like upCounter and downCounter—are facets of the composite. In this case, the Slot bound to &count need not be considered a facet since we can tell that no reference to it can escape from the composite. This demonstrates how the reference passing rules of objects, combined with encapsulation of object state, supports encapsulation of objects within composites. [[composite facets]]
            - The aggregation of a network of objects into a composite is purely subjective—it allows us to hide detail when we wish. The technique works because the possible interactions among disjoint composites obey the same rules as the possible interactions among individual objects.
        - Soft Type Checking
            - Explicit type systems help ensure compatibility between the behavior a client assumes and the behavior its provider implements. Static type systems help catch such assumption mismatches during development, but with two costs in expressive power: 1) Dynamically safe code that can’t be statically checked is rejected. 2) The only kinds of mismatches that can be caught are those that can be checked for statically.
            - By default, E provides only implicit types and dynamic type safety, which catch interface assumption mismatches at the last moment: when a message is not understood by a recip- ient. This still fails safe with no loss of expressive power of the first kind. E does provide optional explicit soft types [CF91], trademarks [Mor73a, Mor73b], and auditors [YM03] for catching assumption mismatches earlier, though still at runtime. Variable declarations and method returns can be annotated by a colon followed by an expression which evaluates to a “guard.” At runtime, a guard determines what values may pass, with no loss of expressive power of the second kind.
                - [[Dan Finlay]] note: This would be similar to using a [[TypeScript]] type enforcer on every function invocation, something that isn’t done widely yet, but I’ve wanted a good tool for.
            - Object definition expressions can be annotated by an implements keyword followed by a list of expressions which evaluate to “auditors.” At runtime, each auditor is given the abstract syntax tree of this object definition expression, to determine whether its instances would indeed implement the property the auditor represents. If the auditor approves, the new instances carry its trademark. This forms the basis for a dynamically extensible code verification system. This dissertation employs only two kinds of auditors, stamps and Data, which we explain here. Further explanation of the auditing framework is beyond the scope of this dissertation.
            - “Data” is both a guard and an auditor. As a guard, the values it passes convey only information, not authority of any kind. Among the conditions an object must satisfy to be considered data, it must be transitively immutable. 
                - [[Dan Finlay]] note: Does this relate to why [[CapTP]] has its serialization requirements of [[record]] vs [[interface]]?
        - Notes on Related Work
            - Reynold’s Gedanken [[Rey70]], a dynamically-typed variant of Algol, seems to be the first language with first-class indefinite extent lexical closures. Gedanken introduced the trade- marking technique explained above [Mor73a, Mor73b]. Gedanken was pathbreaking regard- ing many of the issues covered in this dissertation, and is covered further in Related Work Section 24.1.
            - E’s technique for defining objects by nested lambda instantiation + message dispatch dates back at least to Hewitt’s 1973 Actors languages [HBS73], which combined Gedanken’s lexical closures with Smalltalk’s method dispatch. Actors is covered further in Chapter 23. This notion of object is also hinted at in Hoare’s note on “Record Handling” [Hoa65]. Shroff and Smith’s Type Inference for First-Class Messages with Match-Functions [SS04] explains how to statically type objects defined by this technique. We have not yet applied this or any other static type analysis techniques to E programs.
            - Many prior systems have provided functions as degenerate objects. In Smalltalk [GK76], blocks are a lightweight syntax for defining function-like one-method objects, in which the default method name is elided. The T language [RA82] is a dialect of Scheme in which all closures are objects, and function-invocation syntax invokes one of an object’s methods. A C++ value type can overload “operator()” in order to turn function application into method invocation [ES90].
            - Imperative programming language semantics often describe assignable locations as dis- crete location objects [KCR98], but this notion is not usually made accessible to the pro- grammer. The first programmer-accessible reification of locations seems to be the so-called “ref” type constructor of Algol 68 [vWMPK69]. This notion is widely familiar today as the “ref” of ML [Mil84].
- Personal thoughts
    - 3: Fragile Composition
        - I’m very much looking forward to learning how this text suggests [[communicating event loops]] solve the deadlock problem. It seems to me that at some point, locks are still needed to solve [[The Train & Hotel Problem]], as discussed in the [[Caputi]] [[[[Secure EcmaScript (SES)]] strategy call]].
        - Many of these ideas were familiar to me as an enthusiast of [[Agoric]] software, but I am greatly enjoying gathering references to follow up on. Also, I am just much less familiar with how [[object capability (ocap)]] provide any prescription for avoiding concurrency deadlocks, so that’s looking to be one of the freshest parts of this text to me.
        - Also very excited to get to all the CapDesk stuff. I’ve seen one brief demo of it, and I see it uses petnames, but I’m eager to see any other prior art that I could draw inspiration from.
- Language
    - [[permission]] vs [[authority]]
        - A distinction intended to bring strong distinctions between a variety of security terms. Mark sees these as two sides of a fundamental dichotomy. Isn't married to the words themselves, but sees the concepts as essential.
        - Explanation provided in [[[[Polaris]]: Virus Safe Computing for Windows XP]]
            - Sidebar: Privilege, Permission, and Authority
            - The security community often refers to the Principle of Least Privilege [4]. However,
            - exactly what constitutes a privilege isn’t clear. One attempt at a definition [5] introduces
            - the distinction between permission and authority. The authors define permission to be
            - the set of rules as written down, say in an access control list, and authority to be the set of
            - actions a process can cause to happen. The latter combines the set of permissions with
            - the behavior of parties having these permissions.
            - Consider a web server. The process running the server has permission to read the files of
            - the web site; there is a specific entry in the ACL for each file. Someone visiting the web
            - site has no entry in the ACL but still can read the contents of the file because the server
            - presents the information. Hence, the visitor has authority to read the files even though
            - there is no explicit permission granting the access.
            - Security analysis that considers only permission will be incomplete. Security analysis
            - that includes authority is necessarily limited by our ability to understand the behavior of
            - programs. Fortunately, it is often possible to get a usable bound on the authority
            - available to any process [5].
        - Definitions
            - Permission
                - The rights you're given by the underlying primitives of the security system.
                - The fundamental capabilities that are connecting all other side-effects.
                - A [[object capability (ocap)]] "capability" __is__ a permission under this definition.
            - Authority
                - Those things you can actually do as a result of the composition of the permissions and the permitted actions of other parties.
                - The ultimately delegated and composed results of all permissions and underlying delegations.
                - My impression
                    - Includes behavioral limitations of the actors receiving some permission.
                    - Includes subsequent references that may be passed along initially established permissions.
