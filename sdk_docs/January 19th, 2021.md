- [[LavaMoat]] [[Secure EcmaScript (SES)]] [[endo]] call
    - [[LavaMoat]] Cross-Module global variable access discussion
        - The root package has no policy file
        - The root can write to a global
        - A child package is permitted to read that global
        - Application package is providing a shim that is depended on by its dependencies.
        - Possible approaches
            - allow dependencies to access globals as a form of endowment.
            - Only allow default globals to be endowed via lava-moat config.
        - [[Kumavis]]'s approaches
            - code in the root package is evaluated outside the compartment, so its modifications to the global this are actual.
            - When packages have been configured to allow reads from the global this, they have the root package's global this.
        - Actual examples
            - regenerator-runtime
            - react-devtools
        - They don't work when the setter is in the root package.
        - Questions
            - How does cross-package global interaction work today in Lava Moat?
                - The policyfile is explicit on both sides of the policy: write/read for a given global.
                    - Is not explicit about where the global is coming from.
                    - There is a universal, cross-package global that this permission refers to.
                - [[Mark Miller]] recommends we avoid communicating via truly global state.
                    - Two different modules communicating via the same global would not use globals.
            - Having read access to a module is a form of dependency. It is your responsibility as the module maintainer to explicitly define the package inter-dependency.
                - Why is the root compartment special? Why does it need to be special?
                - Should the root package have a policyfile also?
                    - Would that be an undue burden?
                        - During development, a developer trusts themselves, and the shape of the application may change rapidly.
        - Recommendations
            - When packages have been configured to allow reads from the global this, they have the root package's global this.
            - You do not eval any code outside the root compartment.
                - The [[start compartment]] still has a powerful global (`Date.now()` returns the current date).
                - Child compartments have a powerless global (There is no `Date.now()`).
        - [[Secure EcmaScript (SES)]] removes `Regex.prototype.compile`, and otherwise is standard.
        - Raises challenges of [[debugger]] scope. [[Mark Miller]] says that a debugger broken at a point should be evaluated at the point in scope that the break-point occurs.
    - [[Greater Theory of Reactivity (GTOR)]]
        - "throughput mechanisms" like [[node.js stream]]s
            - Used to creating them in one place, wiring them in another place.
            - The `pipe()` function is meant to be for the wiring.
        - What do you name the producer side of a stream?
            - [[AsyncIterator]]?
                - When using this as a push API, the method names are `next(obj)`, `return(obj)`, `throw(reason)`, but when you're thinking of it as a stream you mean "I'm ending this stream on purpose, and here is the completion value to be associated with the termination", which is distinct from "the last element of a stream"
                    - Throw means I'm terminating because of a problem and am reporting the reason.
                    - [[Mark Miller]] feels the return/throw method names are bizarre to explain for the push API of a stream.
                    - [[Mark Miller]] suggests
                        - `updateState(val)` instead of `next()`
                        - `finish(info)` instead of `return(val)`
                        - The value yielded is the value pulled
                    - [[Kris Kowal]] feels that since a stream is fully symmetric in every way, because a pipe is in fact a bidirectional promise queue of iterations, the naming should not be differentiated between the two directions.
                        - return/finish are synonyms
                        - throw/fail are synonyms also
        - When a piece of code with a generator throws an error, the yield is continued and a `try{}finally{}` block can catch it, because it represents completion.
            - A client does a return or throw
            - The generator does a try/catch or try/finally to intercept that and continue processing instead of leaving the code.
                - Like a `yield()` instead a `finally{}` block
                - The `finally{}` block could break or continue, and put you in a loop with the yield until the next yield.
            - The client of the API then does another `next()`
    - [[pet name]]s injected inline into websites: Possible without a templating language?
        - Is the DOM tree seen by Twitter the one that is shown to the user.
        - [[transclusion]] is now possible to some extent with the [[Shadow DOM]]
        - A full [[DOM]] [[membrane]] could allow this kind of confinement.
            - Naturally confining the DOM is a herculean task.
            - Formerly an investigation ruled out this possibility, but theoretically could be possible.
            - App saw the virtual DOM, but saw only a subtree of the DOM, and was only shown the DOM it expects.
            - Requires removing some DOM features
                - The ability to measure the width of text as measured by CSS.
                    - Depending on the CSS style, you can assign CSS styles such that a visited link could be interpreted.
        - For cases where new code is written for the confined environment, like a [[[[MetaMask]] Snaps]] custom confirmation, it is easier
            - The script can get an opaque object that represents "a name", but the application cannot get a reference to the name.
            - "smells like" [[quasi-literal]]s/[[template literals]] for assertion details.
    - Can [[[[React]] Native]] be confined with [[LavaMoat]]?
        - The [[ses-shim]] should work, just needs to be made to work for the [[Metro]], the [[[[React]] Native]] build system.
        - Any platform is going to be prone to supply chain attacks like this.
        - [[wasm]] could also be used to confine natively compiled code.
            - [[[[LavaMoat]] Native]] would be a version of [[LavaMoat]] that is capable of running with [[[[React]] Native]] and confining native dependencies with [[wasm]] when needed.
